PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                  VAL INT propogate, me )

  #INCLUDE "raytrace.inc"

  PROC throughPut ( [256] INT work,
                    CHAN OF ANY fromPrev, toNext, feedPixels, pixelTrigger,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          pixelTrigger ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  feedPixels ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        feedPixels ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      pixelTrigger ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        feedPixels   ! c.render; x; y
                        pixelTrigger ? kick
                    TRUE
                      SKIP
                  feedPixels ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ work FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ work FROM 0 FOR size ]
                    TRUE
                      SKIP
                  feedPixels ! tag; size; [ work FROM 0 FOR size ]
  :

  PROC pixelBypass ( [256] INT pixels, CHAN OF ANY toPrev, fromNext, fromThis)

    INT  state, command, x, y, size :

    VAL closeDown  IS 0 :
    VAL lubThis    IS 1 :
    VAL lubOther   IS 2 :

    PROC pass ( CHAN OF ANY in, out )

      buffer IS pixels : -- save static chaining
      SEQ i = 0 FOR size
        SEQ
          in  ? [ buffer FROM 0 FOR size ]
          out ! [ buffer FROM 0 FOR size ]
    :

    SEQ
      state := lubThis \/ lubOther
      WHILE state <> closeDown
        PRI ALT
          fromThis ? command
            SEQ
              IF
                command = c.message
                  SEQ
                    fromThis ? size; [ pixels FROM 0 FOR size ]
                    toPrev ! command; size; [ pixels FROM 0 FOR size ]
                command = c.patch
                  SEQ
                    fromThis ? x; y; size
                    toPrev ! command; x; y; size
                    pass ( fromThis, toPrev )
                command = c.stop
                  state := state >< lubThis
          fromNext ? command
            SEQ
              IF
                command = c.message
                  SEQ
                    fromNext ? size; [ pixels FROM 0 FOR size ]
                    toPrev ! command; size; [ pixels FROM 0 FOR size ]
                command = c.patch
                  SEQ
                    fromNext ? x; y; size
                    toPrev ! command; x; y; size
                    pass ( fromNext, toPrev )
                command = c.stop
                  state := state >< lubOther
      toPrev ! c.stop
  :

  -- note the declaration of big vectors OUTSIDE the scope of the
  -- proc, pulling its variables down into internal RAM.
  -- this also frees internal RAM for throughPut and pixelBypass

  --
  -- run data is a vector of
  --
  --  runData [0] ->  ambient R
  --           1      ambient G
  --           2      ambient B
  --           3      rendering mode  -- m.adaptive / m.dumb / m.stochastic
  --           4      patch size
  --           5      scale factor    -- 1 2 or 4
  --           6      screenOrg x
  --           7                y
  --           8                z
  --           9      screen  dxX
  --           10             dyX
  --           11             dzX
  --           12     screen  dxY
  --           13             dyY
  --           14             dzY
  --           15     pinhole  x
  --           16     pinhole  y
  --           17     pinhole  z
  --

  [20] INT grunData :


  [maxNodes][nodeSize] INT cleanTree :    -- for 5 this is 5 kbytes


  [sizeWorld] INT    gworldModel :

  [sizeLights] INT glights :
  [gridSize][gridSize]  INT gsamples :

  [patchSize][patchSize] INT gcolours : -- these are the AREA-AVERAGED colours
                                        -- returned to the grafix cards,
                                        -- not the point samples

  PROC renderer ( CHAN OF ANY workIn, pixelsOut, done )
    [20] INT runData IS grunData :

    [3] REAL32 ambient RETYPES [ runData FROM 0 FOR 3 ] :

    renderingMode IS runData [3] :
    runPatchSize  IS runData [4] :

    [3] REAL32 screenOrg RETYPES [ runData FROM  6 FOR 3 ] :
    [3] REAL32 screendX  RETYPES [ runData FROM  9 FOR 3 ] :
    [3] REAL32 screendY  RETYPES [ runData FROM 12 FOR 3 ] :
    [3] REAL32 pinhole   RETYPES [ runData FROM 15 FOR 3 ] :
    [ treeSize] INT    tree  RETYPES cleanTree :

    [ treeSize] REAL32 ftree RETYPES tree :

    INT freeNode :
    [sizeWorld] INT worldModel IS gworldModel :
    [sizeWorld] REAL32 fworld RETYPES worldModel : -- for floating point access

    INT world.p :  -- pointer used during construction of model
    [sizeLights] INT lights IS glights :
    [sizeLights] REAL32 flights RETYPES lights :

    INT light.p :  -- pointer used during construction of model

    [gridSize ][gridSize] INT samples IS gsamples :
    [gridSize * gridSize] INT rawSamples RETYPES samples :

    [patchSize][patchSize] INT colours IS gcolours :


    PROC normalize ( [3] REAL32 vector, REAL32 oldHyp )
      REAL32 t :
      SEQ
        t :=  (vector [0] * vector [0]) +
             ((vector [1] * vector [1]) +
              (vector [2] * vector [2]))
        oldHyp := SQRT( t )
        vector [0] := vector [0] / oldHyp
        vector [1] := vector [1] / oldHyp
        vector [2] := vector [2] / oldHyp
    :

    PROC dotProduct ( REAL32 a.b, [3] REAL32 a, b )
      a.b := (a[0] * b[0]) + ((a[1] * b[1]) + (a[2] * b[2]))
    :

    [256] INT message :
    INT mess.p :

    PROC wrch ( VAL INT ch )
      IF
        ch = (-7)
          SEQ
            pixelsOut ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
            mess.p := 0
        mess.p = 256
          SKIP
        TRUE
          SEQ
            message [ mess.p] := ch
            mess.p := mess.p + 1
    :


    PROC writen ( VAL INT num)
      [20] INT stack :
      INT sp :
      PROC push (VAL INT push)
        SEQ
          stack[sp] := push
          sp := sp + 1
          SKIP
      :

      PROC pop (INT pop)
        SEQ
          sp := sp - 1
          pop := stack[sp]
          SKIP
      :

      VAL nil IS #DEAD :
      INT n :
      SEQ
        IF
          num < 0
            SEQ
              n := -num
              wrch ( INT '-')
          TRUE
            n := num
        sp := 0
        push (nil)
        WHILE n > 9
          SEQ
            push (n \ 10)
            n := n / 10
        WHILE n <> nil
          SEQ
            wrch ( n + (INT '0'))
            pop (n)
    :


    PROC writeReal ( VAL INT X )
      --Write real number X to channel OUT. Number has IP places of
      --figures before point, DP places after; sign is either space or minus.
      --Total field width is Ip+Dp+2. If value out of range then
      --exponential form used. If Dp is zero then free format using
      --minimum field width is used (exponential form if number out
      --of sensible range), Ip should be zero if Dp is zero. If Ip is
      --zero then the exponential form is used to give Dp places of
      --accuracy (field width is Dp+6). In exponential form the
      --fraction (.1 <= f < 1.) is followed be E, sign (+, -) and the
      --two digit exponent.
      -- IEEE Standard Floating Point Arithmetic.
      -- Single length implementation for 32 bit host.
      -- Martin Bond, Version 6, 16 April 85.

      -- Standard operation routines

      VAL RealShift      IS         8 :
      VAL RealExpSh      IS        23 :
      VAL BitsInFrac     IS        24 :
      VAL RealExp        IS       255 :
      VAL RealXcess      IS       127 :
      VAL RealRBit       IS       128 :
      VAL RealInf        IS #7F800000 :
      VAL RealNaN        IS #7F800001 :
      VAL SignBit        IS #80000000 :
      VAL BitsPerWord    IS        32 :
      --square root constants
      VAL R2C            IS #93000000 :
      VAL R2K            IS #6CFFFFFF :      --word extension always -1
      VAL R2R            IS #B504F334 :

      -- Useful constants.
      VAL RealMin        IS #00800000 :      --min normal number
      VAL RealMax        IS #7F7FFFFF :      --max normal integer
      VAL One            IS #3F800000 :      --unity

      VAL Pi             IS #40490FDB :
      VAL E              IS #402DF854 :
      VAL add IS 0 :
      VAL sub IS 1 :
      VAL mul IS 2 :
      VAL div IS 3 :
      VAL rem IS 4 :
      -- write number constants
      VAL RealBuf        IS     8 :             --buffer size

      VAL Table10        IS    13 :             --exact power ten in word
      VAL Bias10         IS     3 :             --extras for full pow ten range
      VAL MaxDecN        IS     9 :             --maximum dec digits
      VAL R2L            IS #4D10 :             --Log2(10) in low half word

      VAL PowerTenFrac IS [#80000000,
                       #A0000000,
                       #C8000000,
                       #FA000000,
                       #9C400000,
                       #C3500000,
                       #F4240000,
                       #98968000,
                       #BEBC2000,
                       #EE6B2800,
                       #9502F900,
                       #BA43B740,
                       #E8D4A510,
                       #9184E72A] :

      VAL PowerTenExp  IS [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43] :

      VAL BiasTenFrac  IS [#9184E72A,     --P13
                      #CECB8F28,     --P27
                      #EB194F8E] :   --P40

      VAL BiasTenExp   IS [43, 89, 132] :

      VAL BiasTen      IS [14, 28, 41, 54] :  --bias changeover points


      PROC put.byte ( VAL INT byte )
        wrch ( byte)
      :

      PROC ScaleX (INT Xexp, Xfrac, VAL INT Scale)
        --scale x by value of 10^Scale
        INT Carry, Places, Sb, St, Zexp, Zfrac :
        SEQ
          IF
            Scale < 0                           --get abs value of scale
              St := -Scale
            TRUE
              St := Scale
          IF
            St <= Table10                       --easy case, 10 in table
              SEQ
                Zexp := PowerTenExp[St]
                Zfrac := PowerTenFrac[St]
            St = (BiasTen[1]-1)                 --special case
              SEQ
                Zexp := BiasTenExp[1]
                Zfrac := BiasTenFrac[1]
            TRUE                                --apply bias
              SEQ
                IF                              --get power ten bias
                  IF i = 0 FOR Bias10
                    St < BiasTen[i+1]
                      Sb := i
                  TRUE                          --too big
                    Sb := -1
                IF
                  Sb < 0                        --too large
                    Zexp := -1
                  TRUE                          --valid power
                    SEQ
                      St := (St-BiasTen[Sb]) + 1
                      Zexp := (PowerTenExp[St]+BiasTenExp[Sb]) + 1
                      Zfrac, Carry := LONGPROD (PowerTenFrac[St],
                                                  BiasTenFrac[Sb], 0)
                      Places, Zfrac, Carry := NORMALISE (Zfrac, Carry)
                      Zexp := Zexp - Places
          IF
            Zexp < 0                              --out of range
              SEQ
                IF
                  Scale < 0                      --set to big number
                    Zexp := -RealExp
                  TRUE
                    Zexp := RealExp
                Zfrac := SignBit                  --prevent normalisation
            Scale < 0                             --scale down
              SEQ
                Zexp := Xexp - Zexp
                Zfrac, Carry := LONGDIV (Xfrac>>1, 0, Zfrac)
                IF
                  Carry = 0                       --get error in result
                    SEQ
                  TRUE                            --note sticky bit
                    Carry := SignBit
            TRUE                                  --scale up
              SEQ
                Zexp := (Xexp+Zexp) + 1
                Zfrac, Carry := LONGPROD (Xfrac, Zfrac, 0)
          Places, Xfrac, Carry := NORMALISE (Zfrac, Carry)
          Xexp := Zexp - Places
      :

      PROC QuickLog (INT LogX, VAL INT Xexp, Xfrac)
        --cheap approximation of Log10, may be 1 too small.
        INT Borrow, Carry, X :
        SEQ
          --get cheap approx to Log2 of 1.f*2^e as e.f
          Carry, X := SHIFTRIGHT (Xexp, Xfrac<<1, BitsPerWord/2)
          IF
            X < 0                                     --log2 may be small
              SEQ
                X, Carry := LONGPROD (-X, R2L+1, 0)
                Borrow, Carry := LONGDIFF (0, Carry, 0)
                Borrow, LogX := LONGDIFF (0, X, Borrow)
            TRUE                                      --log2 about right
              LogX, Carry := LONGPROD (X, R2L, 0)       --mul by Log10(2)
      :

      PROC Round (INT Xexp, Xfrac, Xint)
        --round number to nearest integer
        INT Places, Guard :
        SEQ
          IF
            Xexp >= BitsPerWord                   --outside valid range
              SEQ
            TRUE                                  --round X to an integer
              SEQ
                Places := BitsPerWord - (Xexp+1)
                Xint, Guard := SHIFTRIGHT (Xfrac, 0, Places)
                IF
                  ((Guard /\ SignBit) = 0) OR     --don't round
                    (((Guard/\(~SignBit))\/(Xint/\1)) = 0)
                    SKIP                          --round down/even
                  TRUE
                    Xint := Xint + 1              --round integer
                Guard, Xfrac := SHIFTLEFT (0, Xint, Places)   --get int as real
                Xexp := Xexp + Guard
      :

      PROC WriteDec ([]INT Buf, INT Length, VAL INT Num)
        --generate unsigned number (assumed to be non-zero)
        INT N, ix, iy :
        SEQ
          N := Num
          ix := 0                           --build in reverse order
          WHILE N <> 0
            SEQ
              INT temp :
              SEQ
                N, temp := LONGDIV (0, N, 10)
                Buf[ix] := temp
              IF
                (ix\/Buf[ix]) = 0           --dump trailing spaces
                  SKIP
                TRUE
                  SEQ
                    Buf[ix] := Buf[ix] + (INT '0')
                    ix := ix + 1
          Length := ix
          ix := ix - 1
          iy := 0
          WHILE iy < ix                     --get correct order
            SEQ
              N := Buf[ix]
              Buf[ix] := Buf[iy]
              Buf[iy] := N
              iy := iy + 1
              ix := ix - 1
      :

      INT Ip, Dp :
      INT Carry, LogX, N, Places, Scale :
      INT Xexp, Xfrac, Xint, Yexp, Yfrac :
      [MaxDecN]INT Buf :
      SEQ
        Ip := 0
        Dp := 0
        Xexp, Xfrac := SHIFTLEFT(0, X/\(~SignBit), RealShift+1)
        IF
          Xexp = RealExp                    --inf or NaN
            SEQ
              IF
                (X /\ SignBit) = 0
                  put.byte (INT ' ')
                TRUE
                  put.byte (INT '-')
              IF
                X = RealNaN
                  SEQ
                    put.byte (INT 'N')
                    put.byte (INT 'a')
                    put.byte (INT 'N')
                TRUE
                  SEQ
                    put.byte (INT 'I')
                    put.byte (INT 'n')
                    put.byte (INT 'f')
              IF
                Dp <> 0                     --pad with spaces
                  SEQ i = 0 FOR (Ip+Dp)-2
                    put.byte (INT ' ')
                TRUE
                  SEQ
              IF
                (Ip = 0) AND (Dp <> 0)      --exp form
                  SEQ
                    put.byte (INT ' ')      --for e+00
                    put.byte (INT ' ')
                    put.byte (INT ' ')
                    put.byte (INT ' ')
                TRUE
                  SEQ
          (Xexp\/Xfrac) = 0                 --zero
            SEQ
              IF
                (X /\ SignBit) = 0
                  put.byte (INT ' ')
                TRUE
                  put.byte (INT '-')
              SEQ i = 0 FOR Ip-1
                put.byte (INT ' ')
              put.byte (INT '0')
              put.byte (INT '.')
              put.byte (INT '0')
              SEQ i = 0 FOR Dp-1
                put.byte (INT ' ')
          TRUE                              --proper value
            SEQ
              IF
                Xexp = 0                    --ensure normal
                  SEQ
                    Places, Xfrac, Carry := NORMALISE (Xfrac, 0)
                    Xexp := - (Places + RealXcess)
                TRUE                        --set top bit
                  SEQ
                    Xfrac := (Xfrac >> 1) \/ SignBit
                    Xexp := Xexp - RealXcess
              Yexp := Xexp                  --save extended X
              Yfrac := Xfrac
              QuickLog (LogX, Xexp, Xfrac)  --get log
              IF
                Dp <> 0                     --field width
                  SEQ
                    N := Ip + Dp            --significant digits
                    IF
                      N > MaxDecN           --don't print too many
                        N := MaxDecN
                      TRUE
                        SEQ
                TRUE
                  N := MaxDecN              --default
              Scale := (N - 1) - LogX
              ScaleX (Xexp, Xfrac, Scale)   --get X in range
              Round (Xexp, Xfrac, Xint)     --now as integer
              IF
                (Xexp > PowerTenExp[N]) OR
                  ((Xexp = PowerTenExp[N]) AND (Xfrac >= PowerTenFrac[N]))
                  SEQ
                    LogX := LogX + 1        --new scale
                    Xexp := Yexp            --reset X
                    Xfrac := Yfrac
                    ScaleX (Xexp, Xfrac, Scale-1)
                    Round (Xexp, Xfrac, Xint)
                TRUE                        --X in correct range
                  SEQ
              WriteDec (Buf, Places, Xint)         --get number string
              IF
                (Dp = 0) AND ((-3) <= LogX) AND (LogX < N)  --good default form
                  SKIP
                (Ip = 0) OR (LogX >= Ip) OR
                  ((-LogX) > Dp)            --use exp form
                  SEQ
                    IF
                      (X /\ SignBit) = 0
                        put.byte (INT ' ')
                      TRUE
                        put.byte (INT '-')
                    put.byte (Buf[0])
                    put.byte (INT '.')
                    IF
                      Dp <> 0               --exp form requested
                        SEQ
                          SEQ i = 1 FOR Dp-1
                            IF
                              i < Places
                                put.byte (Buf[i])
                              i = 1         --only one digit
                                put.byte (INT '0')
                              TRUE          --space fill field
                                put.byte (INT ' ')
                      Places <= 1           --only one digit
                        put.byte (INT '0')
                      TRUE                  --output all digits
                        SEQ i = 1 FOR Places-1
                          put.byte (Buf[i])
                    put.byte (INT 'E')
                    IF
                      LogX < 0
                        SEQ
                          put.byte (INT '-')
                          LogX := -LogX
                      TRUE
                        put.byte (INT '+')
                    put.byte ((LogX/10) + (INT '0'))
                    put.byte ((LogX\10) + (INT '0'))
                    Places := 0             --flag done
                TRUE
                  SKIP
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE                        --output number
                  INT Ipl, Dpl :
                  SEQ
                    IF
                      LogX <= 0                  --always 0.
                        Scale := 0
                      TRUE
                        Scale := LogX
                    IF
                      Dp = 0                     --free format
                        SEQ
                          IF
                            LogX < 0
                              Ipl := 1             --sign and 0.
                            TRUE
                              Ipl := LogX + 1
                          Dpl := Places - LogX
                          IF
                            Dpl <= 0
                              Dpl := 1
                            TRUE
                              SEQ
                      TRUE
                        SEQ
                          Ipl := Ip
                          Dpl := Dp
                    SEQ i = LogX-Ipl FOR Ipl+1
                      IF
                        ((i = LogX) AND (LogX < 0)) OR (i >= Places)
                          put.byte (INT '0')
                        i = (LogX-(Scale+1))
                          IF
                            (X /\ SignBit) = 0
                              put.byte (INT ' ')
                            TRUE
                              put.byte (INT '-')
                        i < (-1)
                          put.byte (INT ' ')
                        (0 <= i) AND (i < Places)
                          put.byte (Buf[i])
                    put.byte (INT '.')
                    SEQ i = (LogX+1) FOR Dpl
                      IF
                        ((i = (LogX+1)) AND (i >= Places)) OR (i < 0)
                          put.byte (INT '0')
                        (0 <= i) AND (i < Places)
                          put.byte (Buf[i])
                        i >= Places
                          put.byte (INT ' ')
    :

    PROC writef ( VAL [] BYTE str, VAL INT a, b, c, d)
      INT chptr, ch, ptr :
      [4] INT args :
      SEQ
        ptr     := 0
        chptr   := 0
        args[0] := a
        args[1] := b
        args[2] := c
        args[3] := d
        WHILE chptr < (SIZE str)
          SEQ
            ch := INT str[chptr]
            IF
              ch = (INT '%')
                SEQ
                  chptr := chptr + 1
                  ch := INT str [chptr]
                  IF
                    (ch = (INT 'I')) OR (ch = (INT 'i'))
                      SEQ
                        writen ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    (ch = (INT 'F')) OR (ch = (INT 'f'))
                      SEQ
                        writeReal ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    TRUE
                      SKIP

              TRUE
                wrch ( ch)
            chptr := chptr + 1
        wrch ( -7)
    :


    PROC initWORDvec ( [] INT vec, VAL INT pattern, words )
      INT dest, xfer :
       
      SEQ
        vec [0] := pattern
        xfer    := 1
        dest    := xfer
        WHILE dest < words
          SEQ
            IF
              (dest + xfer) < words
                [ vec FROM dest FOR xfer ] := [ vec FROM 0 FOR xfer ]
              TRUE
                SEQ
                  xfer := words - dest
                  [ vec FROM dest FOR xfer ] := [ vec FROM 0 FOR xfer ]
            dest := dest + xfer
            xfer := xfer + xfer
    :

     --The classic ray tracing paper is

     --   'An improved illumination model for shaded display'

     --   Turner Whitted CACM June 1980
     --                             -
     --                           . V
     --                    -  -  /
     --                - ^ V'+N /
     --                N |<----.
     --           - \    |    /
     --           R  \   |   / -
     --               \  |-./  V'
     --                \ |a/
     --       __________\|/__________
     --       ///////////////////////
     --                 /
     --             -  /
     --             P  /
     --               /
     --               /
     --              -   -
     --   VN cos a = N.(-V)
     --
     --   N / V' = cos a
     --
     --   N = 1, V = 1
     --            - -
     --   V' = -1/(N.V)
     
     --   hence ( p. 344 CACM)
     --
     --     -    -    - -
     --     V' = V / |V.N|
     --     -    -     -
     --     R  = V' + 2N
     --     -       -   -     -
     --     P  = kf(N + V') - N
     --
     --                   2   2     -    -  2  -1/2
     --      where kf = (kn |V'| - |V' + N'| )
     --
     --     kn = index of refraction
     --                - -
     --   NOTE that if V.N < 0 we are INSIDE the object - be careful about
     --   the refractive index


    PROC reflectRay ( INT reflected, incident,
                      REAL32 Vprime, [3] REAL32 Vvec, BOOL flip )
      --
      -- this code assumes a ray normalized on entry. if it is not, you are in
      -- trouble
      --
      -- normalization is not maintained after a reflection, but from the
      -- geometry of the system ( see above) we can determine that
      -- the ratio of V' to V is the ratio of R' to R
      --
      -- now V is 1, R is 1, so to obtain R from R'
      -- R = (R' * V) / V'
      -- or R = R'/V'
      --
      -- so renormalization now costs 3 divides, not 3 muls, 2 adds and 1 root
      --
      node IS [ ftree FROM incident  FOR nodeSize ] :
      spec IS [ ftree FROM reflected FOR nodeSize ] :
      REAL32 V.N :
      SEQ
        dotProduct ( V.N, [ node FROM n.dx FOR 3 ], [ node FROM n.normx FOR 3 ] )
        IF
          V.N > 0.0 (REAL32)
            [3] INT normal RETYPES [ node FROM n.normx FOR 3 ] :
            SEQ
              normal [0] := normal [0] >< mint
              normal [1] := normal [1] >< mint
              normal [2] := normal [2] >< mint
              Vprime := 1.0 (REAL32) / V.N
              flip   := TRUE
          TRUE
            SEQ
              Vprime := (-1.0 (REAL32)) / V.N
              flip   := FALSE
        --
        --  V'/V = dxV' / dxV
        --                  _ _
        --  V = 1, V' = -1/(N.V)
        --
        --  so dxV' = dxV*Vprime
        --
        --  so Rx = Nx + Nx + dxV*Vprime
        --     Ry = Ny + Ny + dyV*Vprime
        --     Rz = Nz + Nz + dzV*Vprime
        --
        REAL32 twoN :
        SEQ
          twoN        := node [ n.normx] * 2.0 (REAL32)
          Vvec [0]    := node [ n.dx] * Vprime
          spec [n.dx] := Vvec [0]  + twoN

          twoN        := node [ n.normy] * 2.0 (REAL32)
          Vvec [1]    := node [ n.dy] * Vprime
          spec [n.dy] := Vvec [1]  + twoN

          twoN        := node [n.normz] * 2.0 (REAL32)
          Vvec [2]    := node [n.dz] * Vprime
          spec [n.dz] := Vvec [2]  + twoN

        spec [ n.dx] := spec [ n.dx] / Vprime
        spec [ n.dy] := spec [ n.dy] / Vprime
        spec [ n.dz] := spec [ n.dz] / Vprime

        spec [ n.startx] := node [ n.sectx] + node [ n.normx]
        spec [ n.starty] := node [ n.secty] + node [ n.normy]
        spec [ n.startz] := node [ n.sectz] + node [ n.normz]
    :
    PROC refractRay ( INT refracted, incident,
                      REAL32 Vprime, [3] REAL32 Vvec,
                      BOOL   flip, totalInternal )
      --   _       _   _     _
      --   P  = kf(N + V') - N
      --
      --                  2    2   _    _  2  -1/2
      --    where kf = (kn |V'| - |V' + N'| )
      --
      --    kn = index of refraction
      --               _ _
      --  NOTE that if V.N < 0 we are INSIDE the object - be careful about
      --  the refractive index


      node IS [ ftree FROM incident  FOR nodeSize ] :
      [nodeSize] INT inode RETYPES node :

      frac IS [ ftree FROM refracted FOR nodeSize ] :

      VAL  objptr IS inode  [ n.objptr] :  -- points to size word
      VAL  kn     IS fworld [ objptr + (o.refix + 1)] : -- skip size word

      REAL32 kn.Vprime, Vprime.plus.N :

      [3] REAL32 t : -- temporary vector

      [3] REAL32 norm IS [ node FROM n.normx FOR 3 ] :
      SEQ
        IF
          flip
            kn.Vprime := (Vprime * Vprime) / kn
          TRUE
            kn.Vprime := (Vprime * Vprime) * kn

        t [0] := norm [0] + Vvec [0]
        t [1] := norm [1] + Vvec [1]
        t [2] := norm [2] + Vvec [2]

        Vprime.plus.N  := (t [0] * t [0]) +
                         ((t [1] * t [1]) +
                          (t [2] * t [2]))

        IF
          Vprime.plus.N > kn.Vprime
            totalInternal := TRUE
          TRUE
            REAL32 kf2, kf :
            SEQ
              totalInternal := FALSE

              kf2 := kn.Vprime - Vprime.plus.N
              kf := SQRT ( kf2 )

              t [0] := t [0] / kf  -- get kf (N + V')
              t [1] := t [1] / kf
              t [2] := t [2] / kf

              frac [ n.dx] := t [0] - norm [0]
              frac [ n.dy] := t [1] - norm [1]
              frac [ n.dz] := t [2] - norm [2]

              normalize ( [ frac FROM n.dx FOR 3 ], kf )

              frac [ n.startx] := node [ n.sectx] - node [ n.normx]
              frac [ n.starty] := node [ n.secty] - node [ n.normy]
              frac [ n.startz] := node [ n.sectz] - node [ n.normz]
    :

    --
    --  the leaf intersector processes act on nodes in the shade tree,
    --  and either set the t record to 0 if no intersection, or
    --  set up t, sectxyz, normxyz if intersection occurs
    --  they locally test for t < nastyFrig to save computation
    --
    VAL minSect IS 0.001 (REAL32) :
    VAL a.11  IS 0:
    VAL a.12  IS 1:
    VAL a.13  IS 2:
    VAL a.21  IS 3:
    VAL a.22  IS 4:
    VAL a.23  IS 5:
    VAL a.31  IS 6:
    VAL a.32  IS 7:
    VAL a.33  IS 8:

    VAL p.xx  IS 0:
    VAL p.yy  IS 1:
    VAL p.zz  IS 2:

    PROC TransLocal(VAL [9] REAL32 matrix,[3] REAL32 point )
      [3] REAL32 newpoint:
      SEQ
        newpoint[p.xx] := (( matrix[a.11] * point[p.xx] ) +
                          (( matrix[a.12] * point[p.yy] ) +
                           ( matrix[a.13] * point[p.zz] )))
        newpoint[p.yy] := (( matrix[a.21] * point[p.xx] ) +
                          (( matrix[a.22] * point[p.yy] ) +
                           ( matrix[a.23] * point[p.zz] )))
        newpoint[p.zz] := (( matrix[a.31] * point[p.xx] ) +
                          (( matrix[a.32] * point[p.yy] ) +
                           ( matrix[a.33] * point[p.zz] )))
        SEQ i = 0 FOR 3
          point[i] := newpoint[i]
    :

    PROC TransGlobal(VAL [9] REAL32 matrix,[3] REAL32 point )
      [9] REAL32 invers:
      SEQ
        invers[a.11]:=matrix[a.11]
        invers[a.12]:=matrix[a.21]
        invers[a.13]:=matrix[a.31]
        invers[a.21]:=matrix[a.12]
        invers[a.22]:=matrix[a.22]
        invers[a.23]:=matrix[a.32]
        invers[a.31]:=matrix[a.13]
        invers[a.32]:=matrix[a.23]
        invers[a.33]:=matrix[a.33]
        TransLocal(invers,point)
    :

    PROC sphereSect ( [nodeSize] REAL32 node, VAL [] REAL32 sphere )
      REAL32 xoff, yoff, zoff,
             xcomp, ycomp, zcomp,
             minusb, rootb2m4ac,
             b2, c :
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :
      SEQ
        xoff := node [ n.startx] - sphere [ s.x]
        yoff := node [ n.starty] - sphere [ s.y]
        zoff := node [ n.startz] - sphere [ s.z]

        xcomp := xoff * node [ n.dx]
        ycomp := yoff * node [ n.dy]
        zcomp := zoff * node [ n.dz]

        minusb := -(xcomp + (ycomp + zcomp))
        b2     := minusb * minusb

        xcomp := xoff * xoff
        ycomp := yoff * yoff
        zcomp := zoff * zoff

        c := (xcomp + (ycomp + zcomp)) - (sphere [s.rad] * sphere [s.rad])
        IF
          b2 > c
            REAL32 t1, t2 :
            BOOL proceed, t2ok, t1ok :
            SEQ
              rootb2m4ac := SQRT (b2 - c )
              t1 := minusb - rootb2m4ac
              t2 := minusb + rootb2m4ac
              IF
                t1 > minSect
                  t1ok := TRUE
                TRUE
                  t1ok := FALSE
              IF
                t2 > minSect
                  t2ok := TRUE
                TRUE
                  t2ok := FALSE
              IF
                t1ok AND t2ok
                  SEQ
                    proceed := TRUE
                    IF
                      t2 > t1
                        t := t1
                      TRUE
                        t := t2
                t1ok
                  SEQ
                    t := t1
                    proceed := TRUE
                t2ok
                  SEQ
                    t := t2
                    proceed := TRUE
                TRUE
                  proceed := FALSE
              IF
                proceed
                  SEQ
                    node [ n.sectx] := (node [ n.dx] * t) + node [ n.startx]
                    node [ n.secty] := (node [ n.dy] * t) + node [ n.starty]
                    node [ n.sectz] := (node [ n.dz] * t) + node [ n.startz]

                    node [ n.normx] := (node [n.sectx] - sphere [s.x]) / sphere [s.rad]
                    node [ n.normy] := (node [n.secty] - sphere [s.y]) / sphere [s.rad]
                    node [ n.normz] := (node [n.sectz] - sphere [s.z]) / sphere [s.rad]

                TRUE
                  iNode [n.t] := 0  -- no intersection
          TRUE
            iNode [n.t] := 0
    :

    PROC ellipsoidSect ( [nodeSize] REAL32 node, VAL [] REAL32 ellipsoid )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 aa,bb,cc,b2mac,rootb2mac,length:
      [3] REAL32 point :
      [3] REAL32 normal:
      [9] REAL32 matrix:
      SEQ
        SEQ i = 0 FOR 3
          point[i] := node[ i + n.startx] - ellipsoid[i + e.x]
        SEQ i = 0 FOR 3
          normal[i] := node[ i + n.dx]
        SEQ i = 0 FOR 9
          matrix[i] := ellipsoid[i + e.a11]
        TransLocal(matrix,point)
        SEQ i = 0 FOR 3
          point[i] := point[i] / ellipsoid[e.radx + i]
        TransLocal(matrix,normal)
        SEQ i = 0 FOR 3
          normal[i] := normal[i] / ellipsoid[e.radx + i]
        dotProduct( aa, normal, normal )
        dotProduct( bb, normal, point  )
        dotProduct( cc, point,  point  )
        cc := ( cc - 1.0 (REAL32) )
        b2mac := (bb * bb) - (aa * cc)
        IF
          b2mac > 0.0 (REAL32)
            REAL32 t1, t2 :
            BOOL proceed, t2ok, t1ok :
            SEQ
              rootb2mac := SQRT ( b2mac )
              t1 := -((rootb2mac + bb) / aa)
              t2 :=  ((rootb2mac - bb) / aa)
              IF
                t1 > minSect
                  t1ok := TRUE
                TRUE
                  t1ok := FALSE
              IF
                t2 > minSect
                  t2ok := TRUE
                TRUE
                  t2ok := FALSE
              IF
                t1ok AND t2ok
                  SEQ
                    proceed := TRUE
                    IF
                      t2 > t1
                        t := t1
                      TRUE
                        t := t2
                t1ok
                  SEQ
                    t := t1
                    proceed := TRUE
                t2ok
                  SEQ
                    t := t2
                    proceed := TRUE
                TRUE
                  proceed := FALSE
              IF
                proceed
                  SEQ
                    SEQ i = 0 FOR 3
                      point [i] := ((normal [i] * t) + point [i])
                    SEQ i = 0 FOR 3
                      normal [i] := point [i] / ellipsoid[e.radx + i]
                    SEQ i = 0 FOR 3
                      point [i] := point [i] * ellipsoid[e.radx + i]
                    TransGlobal(matrix,point)
                    TransGlobal(matrix,normal)
                    node [ n.sectx] := (ellipsoid [e.x] + point [p.xx])
                    node [ n.secty] := (ellipsoid [e.y] + point [p.yy])
                    node [ n.sectz] := (ellipsoid [e.z] + point [p.zz])
                    normalize(normal,length)
                    node [ n.normx] := normal [ p.xx]
                    node [ n.normy] := normal [ p.yy]
                    node [ n.normz] := normal [ p.zz]
                TRUE
                  iNode [n.t] := 0  -- no intersection
          TRUE
            iNode [n.t] := 0
    :

    PROC cylinderSect ( [nodeSize] REAL32 node, VAL [] REAL32 cylinder )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 t1,t2,t3,t4,t12,t34:
      BOOL t1ok,t2ok,t3ok,t4ok:
      BOOL proceed12,proceed34:
      REAL32 zaxis:
      REAL32 aa,bb,cc,b2mac,rootb2mac,length:
      [3] REAL32 point :
      [3] REAL32 normal:
      [9] REAL32 matrix:
      SEQ
        SEQ i = 0 FOR 3
          point[i] := node[ i + n.startx] - cylinder[i + c.x]
        SEQ i = 0 FOR 3
          normal[i] := node[ i + n.dx]
        SEQ i = 0 FOR 9
          matrix[i] := cylinder[i + c.a11]
        TransLocal(matrix,point)
        point[0] := point[0] / cylinder[c.rad]
        point[1] := point[1] / cylinder[c.rad]
        point[2] := point[2] / cylinder[c.len]
        TransLocal(matrix,normal)
        normal[0] := normal[0] / cylinder[c.rad]
        normal[1] := normal[1] / cylinder[c.rad]
        normal[2] := normal[2] / cylinder[c.len]
        aa := (normal[0] * normal[0]) + (normal[1] * normal[1])
        bb := (normal[0] *  point[0]) + (normal[1] *  point[1])
        cc := ( point[0] *  point[0]) + ( point[1] *  point[1])
        cc := ( cc - 1.0 (REAL32) )
        b2mac := (bb * bb) - (aa * cc)
        IF
          b2mac > 0.0 (REAL32)
            SEQ
              rootb2mac := SQRT ( b2mac )
              t1 := -((rootb2mac + bb) / aa)
              t2 :=  ((rootb2mac - bb) / aa)
              zaxis := point[2] + (t1 * normal[2])
              IF
                zaxis < 0.0 (REAL32)
                  t1ok := FALSE
                zaxis > 1.0 (REAL32)
                  t1ok := FALSE
                t1 > minSect
                  t1ok := TRUE
                TRUE
                  t1ok := FALSE
              zaxis := point[2] + (t2 * normal[2])
              IF
                zaxis < 0.0 (REAL32)
                  t2ok := FALSE
                zaxis > 1.0 (REAL32)
                  t2ok := FALSE
                t2 > minSect
                  t2ok := TRUE
                TRUE
                  t2ok := FALSE
              IF
                t1ok AND t2ok
                  SEQ
                    proceed12 := TRUE
                    IF
                      t2 > t1
                        t12 := t1
                      TRUE
                        t12 := t2
                t1ok
                  SEQ
                    t12 := t1
                    proceed12 := TRUE
                t2ok
                  SEQ
                    t12 := t2
                    proceed12 := TRUE
                TRUE
                  proceed12 := FALSE
          TRUE
            SEQ
              proceed12 := FALSE
              t1ok := FALSE
              t2ok := FALSE
        IF
          normal[2] = 0.0 (REAL32)
            SEQ
              proceed34 := FALSE
              t3ok := FALSE
              t4ok := FALSE
          TRUE
            SEQ
              t3  := ((   - point[2] ) / normal[2])
              t4  := (( 1.0 (REAL32) - point[2] ) / normal[2])

              IF
                t3 < minSect
                  t3ok := FALSE
                ( (aa * (t3 * t3)) + (bb * (2.0 (REAL32) * t3)) ) < (-cc)
                  t3ok := TRUE
                TRUE
                  t3ok := FALSE
              IF
                t4 < minSect
                  t4ok := FALSE
                ( (aa * (t4 * t4)) + (bb * (2.0 (REAL32) * t4)) ) < (-cc)
                  t4ok := TRUE
                TRUE
                  t4ok := FALSE
              IF
                t3ok AND t4ok
                  SEQ
                    proceed34 := TRUE
                    IF
                      t4 > t3
                        SEQ
                          t34 := t3
                          zaxis := 0.0 (REAL32)
                      TRUE
                        SEQ
                          t34 := t4
                          zaxis := cylinder[ c.len]
                t3ok
                  SEQ
                    t34 := t3
                    zaxis := 0.0 (REAL32)
                    proceed34 := TRUE
                t4ok
                  SEQ
                    t34 := t4
                    zaxis := cylinder [c.len]
                    proceed34 := TRUE
                TRUE
                  proceed34 := FALSE
        IF
          proceed12 AND proceed34
            IF
              t34 > t12
                SEQ
                  t := t12
                  point [0] := ((normal [0] * t) + point [0]) * cylinder[c.rad]
                  point [1] := ((normal [1] * t) + point [1]) * cylinder[c.rad]
                  point [2] := ((normal [2] * t) + point [2]) * cylinder[c.len]
                  normal [0] := point [0]
                  normal [1] := point [1]
                  normal [2] := 0.0 (REAL32)
                  TransGlobal(matrix,point)
                  node [ n.sectx] := (cylinder [c.x] + point [p.xx])
                  node [ n.secty] := (cylinder [c.y] + point [p.yy])
                  node [ n.sectz] := (cylinder [c.z] + point [p.zz])
                  TransGlobal(matrix,normal)
                  normalize(normal,length)
                  node [ n.normx] := normal [ p.xx]
                  node [ n.normy] := normal [ p.yy]
                  node [ n.normz] := normal [ p.zz]
              TRUE
                SEQ
                  t := t34
                  point [0] := ((normal [0] * t) + point [0]) * cylinder[c.rad]
                  point [1] := ((normal [1] * t) + point [1]) * cylinder[c.rad]
                  point [2] := zaxis
                  normal [0] := 0.0 (REAL32)
                  normal [1] := 0.0 (REAL32)
                  normal [2] := 1.0 (REAL32)
                  TransGlobal(matrix,point)
                  node [ n.sectx] := (cylinder [c.x] + point [p.xx])
                  node [ n.secty] := (cylinder [c.y] + point [p.yy])
                  node [ n.sectz] := (cylinder [c.z] + point [p.zz])
                  TransGlobal(matrix,normal)
                  node [ n.normx] := normal [ p.xx]
                  node [ n.normy] := normal [ p.yy]
                  node [ n.normz] := normal [ p.zz]
          proceed12
            SEQ
              t := t12
              point [0] := ((normal [0] * t) + point [0]) * cylinder[c.rad]
              point [1] := ((normal [1] * t) + point [1]) * cylinder[c.rad]
              point [2] := ((normal [2] * t) + point [2]) * cylinder[c.len]
              normal [0] := point [0]
              normal [1] := point [1]
              normal [2] := 0.0 (REAL32)
              TransGlobal(matrix,point)
              node [ n.sectx] := (cylinder [c.x] + point [p.xx])
              node [ n.secty] := (cylinder [c.y] + point [p.yy])
              node [ n.sectz] := (cylinder [c.z] + point [p.zz])
              TransGlobal(matrix,normal)
              normalize(normal,length)
              node [ n.normx] := normal [ p.xx]
              node [ n.normy] := normal [ p.yy]
              node [ n.normz] := normal [ p.zz]
          proceed34
            SEQ
              t := t34
              point [0] := ((normal [0] * t) + point [0]) * cylinder[c.rad]
              point [1] := ((normal [1] * t) + point [1]) * cylinder[c.rad]
              point [2] := zaxis
              normal [0] := 0.0 (REAL32)
              normal [1] := 0.0 (REAL32)
              normal [2] := 1.0 (REAL32)
              TransGlobal(matrix,point)
              node [ n.sectx] := (cylinder [c.x] + point [p.xx])
              node [ n.secty] := (cylinder [c.y] + point [p.yy])
              node [ n.sectz] := (cylinder [c.z] + point [p.zz])
              TransGlobal(matrix,normal)
              node [ n.normx] := normal [ p.xx]
              node [ n.normy] := normal [ p.yy]
              node [ n.normz] := normal [ p.zz]
          TRUE
            iNode [n.t] := 0  -- no intersection
    :

    PROC coneSect ( [nodeSize] REAL32 node, VAL [] REAL32 cone )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 t1,t2,t3,t4,t12,t34:
      BOOL t1ok,t2ok,t3ok,t4ok:
      BOOL proceed12,proceed34:
      REAL32 zaxis:
      REAL32 aa,bb,cc,b2mac,rootb2mac,length:
      REAL32 delta,delta.2,bma:
      [3] REAL32 point :
      [3] REAL32 normal:
      [9] REAL32 matrix:
      SEQ
        bma := cone[co.radb] - cone[co.rada]
        delta := (cone[co.radb]/cone[co.rada]) - 1.0 (REAL32)
        delta.2 := delta * delta
        SEQ i = 0 FOR 3
          point[i] := node[ i + n.startx] - cone[i + co.x]
        SEQ i = 0 FOR 3
          normal[i] := node[ i + n.dx]
        SEQ i = 0 FOR 9
          matrix[i] := cone[i + co.a11]
        TransLocal(matrix,point)
        point[0] := point[0] / cone[co.rada]
        point[1] := point[1] / cone[co.rada]
        point[2] := point[2] / cone[co.len]
        TransLocal(matrix,normal)
        normal[0] := normal[0] / cone[co.rada]
        normal[1] := normal[1] / cone[co.rada]
        normal[2] := normal[2] / cone[co.len]
        aa := (((normal[0] * normal[0]) + (normal[1] * normal[1])) -
              ((normal[2] * normal[2]) * delta.2))
        bb := (((normal[0] *  point[0]) + (normal[1] *  point[1])) -
              (((normal[2] *  point[2]) * delta.2) + (delta * normal[2])))
        cc := ((( point[0] *  point[0]) +
                ( point[1] *  point[1])) -
                ((( point[2] *  point[2]) * delta.2) +
                 (( delta *  point[2]) * 2.0 (REAL32) )))
        cc := ( cc - 1.0 (REAL32) )
        b2mac := (bb * bb) - (aa * cc)
        IF
          b2mac > 0.0 (REAL32)
            SEQ
              rootb2mac := SQRT ( b2mac )
              t1 := -((rootb2mac + bb) / aa)
              t2 :=  ((rootb2mac - bb) / aa)
              zaxis := point[2] + (normal[2] * t1)
              IF
                zaxis < 0.0 (REAL32)
                  t1ok := FALSE
                zaxis > 1.0 (REAL32)
                  t1ok := FALSE
                t1 > minSect
                  t1ok := TRUE
                TRUE
                  t1ok := FALSE
              zaxis := point[2] + (normal[2] * t2)
              IF
                zaxis < 0.0 (REAL32)
                  t2ok := FALSE
                zaxis > 1.0 (REAL32)
                  t2ok := FALSE
                t2 > minSect
                  t2ok := TRUE
                TRUE
                  t2ok := FALSE
              IF
                t1ok AND t2ok
                  SEQ
                    proceed12 := TRUE
                    IF
                      t2 > t1
                        t12 := t1
                      TRUE
                        t := t2
                t1ok
                  SEQ
                    t12 := t1
                    proceed12 := TRUE
                t2ok
                  SEQ
                    t12 := t2
                    proceed12 := TRUE
                TRUE
                  proceed12 := FALSE
          TRUE
            SEQ
              proceed12 := FALSE
              t1ok := FALSE
              t2ok := FALSE
        IF
          normal[2] = 0.0 (REAL32)
            SEQ
              proceed34 := FALSE
              t3ok := FALSE
              t4ok := FALSE
          TRUE
            SEQ
              t3  := ((   - point[2] ) / normal[2])
              t4  := (( 1.0 (REAL32) - point[2] ) / normal[2])
              IF
                t3 < minSect
                  t3ok := FALSE
                ( (aa * (t3 * t3)) + (bb * (2.0 (REAL32) * t3)) ) < (-cc)
                  t3ok := TRUE
                TRUE
                  t3ok := FALSE
              IF
                t4 < minSect
                  t4ok := FALSE
                ( (aa * (t4 * t4)) + (bb * (2.0 (REAL32) * t4)) ) < (-cc)
                  t4ok := TRUE
                TRUE
                  t4ok := FALSE
              IF
                t3ok AND t4ok
                  SEQ
                    proceed34 := TRUE
                    IF
                      t4 > t3
                        t34 := t3
                      TRUE
                        t34 := t4
                t3ok
                  SEQ
                    t34 := t3
                    proceed34 := TRUE
                t4ok
                  SEQ
                    t34 := t4
                    proceed34 := TRUE
                TRUE
                  proceed34 := FALSE
        IF
          proceed12 AND proceed34
            IF
              t34 > t12
                REAL32 sinus,cosinus,hyperbole:
                SEQ
                  hyperbole := SQRT(((bma * bma) + (cone[co.len] * cone[co.len])))
                  cosinus := cone[co.len] / hyperbole
                  sinus := bma / hyperbole
                  t := t12
                  point [0] := ((normal [0] * t) + point [0]) * cone[co.rada]
                  point [1] := ((normal [1] * t) + point [1]) * cone[co.rada]
                  point [2] := ((normal [2] * t) + point [2]) * cone[co.len]
                  normal [0] := point [0]
                  normal [1] := point [1]
                  normal [2] := 0.0 (REAL32)
                  normalize(normal,length)
                  normal [0] := normal [0] * cosinus
                  normal [1] := normal [1] * cosinus
                  normal [2] := - sinus
                  TransGlobal(matrix,point)
                  node [ n.sectx] := (cone [co.x] + point [p.xx])
                  node [ n.secty] := (cone [co.y] + point [p.yy])
                  node [ n.sectz] := (cone [co.z] + point [p.zz])
                  TransGlobal(matrix,normal)
                  node [ n.normx] := normal [ p.xx]
                  node [ n.normy] := normal [ p.yy]
                  node [ n.normz] := normal [ p.zz]
              TRUE
                SEQ
                  t := t34
                  point [0] := ((normal [0] * t) + point [0]) * cone[co.rada]
                  point [1] := ((normal [1] * t) + point [1]) * cone[co.rada]
                  point [2] := ((normal [2] * t) + point [2])
                  normal [0] := 0.0 (REAL32)
                  normal [1] := 0.0 (REAL32)
                  normal [2] := 1.0 (REAL32)
                  point [2] := point [2] * cone [co.len]
                  TransGlobal(matrix,point)
                  node [ n.sectx] := (cone [co.x] + point [p.xx])
                  node [ n.secty] := (cone [co.y] + point [p.yy])
                  node [ n.sectz] := (cone [co.z] + point [p.zz])
                  TransGlobal(matrix,normal)
                  node [ n.normx] := normal [ p.xx]
                  node [ n.normy] := normal [ p.yy]
                  node [ n.normz] := normal [ p.zz]
          proceed12
            REAL32 sinus,cosinus,hyperbole:
            SEQ
              hyperbole := SQRT(((bma * bma) + (cone[co.len] * cone[co.len])))
              cosinus := cone[co.len] / hyperbole
              sinus := bma / hyperbole
              t := t12
              point [0] := ((normal [0] * t) + point [0]) * cone[co.rada]
              point [1] := ((normal [1] * t) + point [1]) * cone[co.rada]
              point [2] := ((normal [2] * t) + point [2]) * cone[co.len]
              normal [0] := point [0]
              normal [1] := point [1]
              normal [2] := 0.0 (REAL32)
              normalize(normal,length)
              normal [0] := normal [0] * cosinus
              normal [1] := normal [1] * cosinus
              normal [2] := - sinus
              TransGlobal(matrix,point)
              node [ n.sectx] := (cone [co.x] + point [p.xx])
              node [ n.secty] := (cone [co.y] + point [p.yy])
              node [ n.sectz] := (cone [co.z] + point [p.zz])
              TransGlobal(matrix,normal)
              node [ n.normx] := normal [ p.xx]
              node [ n.normy] := normal [ p.yy]
              node [ n.normz] := normal [ p.zz]
          proceed34
            SEQ
              t := t34
              point [0] := ((normal [0] * t) + point [0]) * cone[co.rada]
              point [1] := ((normal [1] * t) + point [1]) * cone[co.rada]
              point [2] := ((normal [2] * t) + point [2])
              normal [0] := 0.0 (REAL32)
              normal [1] := 0.0 (REAL32)
              normal [2] := 1.0 (REAL32)
              point [2] := point [2] * cone [co.len]
              TransGlobal(matrix,point)
              node [ n.sectx] := (cone [co.x] + point [p.xx])
              node [ n.secty] := (cone [co.y] + point [p.yy])
              node [ n.sectz] := (cone [co.z] + point [p.zz])
              TransGlobal(matrix,normal)
              node [ n.normx] := normal [ p.xx]
              node [ n.normy] := normal [ p.yy]
              node [ n.normz] := normal [ p.zz]
          TRUE
            iNode [n.t] := 0  -- no intersection
    :

    PROC planeSect ( [nodeSize] REAL32 node, VAL [] REAL32 plane )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :
      REAL32 pw,rw,ou,ov :
      [3] REAL32 q :
      BOOL proceed:
      SEQ
        rw := (( plane [ p.wx ] * node [ n.dx ] ) +
               ( plane [ p.wy ] * node [ n.dy ] )) +
               ( plane [ p.wz ] * node [ n.dz ] )
        IF
          rw <> 0.0 (REAL32)
            SEQ
              pw := (( plane [ p.wx ] * ( node [ n.startx ] - plane [ p.x ] )) +
                     ( plane [ p.wy ] * ( node [ n.starty ] - plane [ p.y ] ))) +
                     ( plane [ p.wz ] * ( node [ n.startz ] - plane [ p.z ] ))
              t := - ( pw / rw )
              IF
                t > 0.0 (REAL32)
                  SEQ
                    SEQ i = 0 FOR 3
                      q [i] := node [ n.startx + i ] + ( node [ n.dx + i ] * t )
                    ou := (( plane [ p.ux ] * ( q[0] - plane [ p.x ] )) +
                           ( plane [ p.uy ] * ( q[1] - plane [ p.y ] ))) +
                           ( plane [ p.uz ] * ( q[2] - plane [ p.z ] ))
                    IF
                      ou < 0.0 (REAL32)
                        proceed := FALSE
                      ou > plane [ p.sizeu ]
                        proceed := FALSE
                      TRUE
                        proceed := TRUE
                    IF
                      proceed  -- e.g. value on u axis valid.
                        SEQ
                          ov := (( plane [ p.vx ] * ( q [0] - plane [ p.x ] )) +
                                 ( plane [ p.vy ] * ( q [1] - plane [ p.y ] ))) +
                                 ( plane [ p.vz ] * ( q [2] - plane [ p.z ] ))
                          IF
                            ov < 0.0 (REAL32)
                              proceed := FALSE
                            ov > plane [ p.sizev ]
                              proceed := FALSE
                            TRUE
                              SKIP
                          IF
                            proceed  -- e.g. value on u and v axis valid
                              SEQ i = 0 FOR 3
                                SEQ
                                  node [ n.sectx + i ] := q [i]
                                  IF
                                    rw < 0.0 (REAL32)
                                      node [ n.normx + i ] := plane [ p.wx + i ]
                                    TRUE
                                      node [ n.normx + i ] := - plane [ p.wx + i ]
                            TRUE
                              iNode [n.t] := 0
                      TRUE
                        iNode [n.t] := 0
                TRUE
                  iNode [n.t] := 0
          TRUE
            iNode [n.t] := 0  -- no intersection
    :

    PROC xyPlaneSect ( [nodeSize] REAL32 node, VAL [] REAL32 plane )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 aa,bb:
      BOOL proceed:
      SEQ
        IF
          node [ n.dz ] <> 0.0 (REAL32)
            SEQ
              t := ( plane [ pxy.z ] - node [ n.startz ] ) / node [ n.dz ]
              IF
                t > 0.0 (REAL32)
                  SEQ
                    aa := node [ n.startx ] + ( node [ n.dx ] * t )
                    IF
                      aa < plane [ pxy.x ]
                        proceed := FALSE
                      aa > ( plane [ pxy.x ] + plane [ pxy.sizex ] )
                        proceed := FALSE
                      TRUE
                        proceed := TRUE
                    IF
                      proceed  -- e.g. value on x axis valid
                        SEQ
                          bb := node [ n.starty ] + ( node [ n.dy ] * t )
                          IF
                            bb < plane [ pxy.y ]
                              proceed := FALSE
                            bb > ( plane [ pxy.y ] + plane [ pxy.sizey ] )
                              proceed := FALSE
                            TRUE
                              SKIP
                          IF
                            proceed  -- e.g. value on y axis valid
                              SEQ
                                node [ n.sectx] := aa
                                node [ n.secty] := bb
                                node [ n.sectz] := plane [ pxy.z ]
                                node [ n.normx] := 0.0 (REAL32)
                                node [ n.normy] := 0.0 (REAL32)
                                IF
                                  node [ n.dz ] > 0.0 (REAL32)
                                    node [ n.normz] := -1.0 (REAL32)
                                  TRUE
                                    node [ n.normz] := 1.0 (REAL32)
                            TRUE
                              iNode [n.t] := 0
                      TRUE
                        iNode [n.t] := 0
                TRUE
                  iNode [n.t] := 0
          TRUE
            iNode [n.t] := 0  -- no intersection
    :

    PROC yzPlaneSect ( [nodeSize] REAL32 node, VAL [] REAL32 plane )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 aa,bb:
      BOOL proceed:
      SEQ
        IF
          node [ n.dx ] <> 0.0 (REAL32)
            SEQ
              t := ( plane [ pyz.x ] - node [ n.startx ] ) / node [ n.dx ]
              IF
                t > 0.0 (REAL32)
                  SEQ
                    aa := node [ n.startz ] + ( node [ n.dz ] * t )
                    IF
                      aa < plane [ pyz.z ]
                        proceed := FALSE
                      aa > ( plane [ pyz.z ] + plane [ pyz.sizez ] )
                        proceed := FALSE
                      TRUE
                        proceed := TRUE
                    IF
                      proceed  -- e.g. value on z axis valid
                        SEQ
                          bb := node [ n.starty ] + ( node [ n.dy ] * t )
                          IF
                            bb < plane [ pyz.y ]
                              proceed := FALSE
                            bb > ( plane [ pyz.y ] + plane [ pyz.sizey ] )
                              proceed := FALSE
                            TRUE
                              SKIP
                          IF
                            proceed  -- e.g. value on y axis valid
                              SEQ
                                node [ n.sectx] := plane [ pyz.x ]
                                node [ n.secty] := bb
                                node [ n.sectz] := aa
                                IF
                                  node [ n.dx ] > 0.0 (REAL32)
                                    node [ n.normx] := -1.0 (REAL32)
                                  TRUE
                                    node [ n.normx] := 1.0 (REAL32)
                                node [ n.normy] := 0.0 (REAL32)
                                node [ n.normz] := 0.0 (REAL32)
                            TRUE
                              iNode [n.t] := 0
                      TRUE
                        iNode [n.t] := 0
                TRUE
                  iNode [n.t] := 0
          TRUE
            iNode [n.t] := 0  -- no intersection
    :

    PROC xzPlaneSect ( [nodeSize] REAL32 node, VAL [] REAL32 plane )
      [nodeSize] INT iNode RETYPES node :
      t IS node [n.t] :

      REAL32 aa,bb:
      BOOL proceed:
      SEQ
        IF
          node [ n.dy ] <> 0.0 (REAL32)
            SEQ
              t := ( plane [ pxz.y ] - node [ n.starty ] ) / node [ n.dy ]
              IF
                t > 0.0 (REAL32)
                  SEQ
                    aa := node [ n.startx ] + ( node [ n.dx ] * t )
                    IF
                      aa < plane [ pxz.x ]
                        proceed := FALSE
                      aa > ( plane [ pxz.x ] + plane [ pxz.sizex ] )
                        proceed := FALSE
                      TRUE
                        proceed := TRUE
                    IF
                      proceed  -- e.g. value on x axis valid
                        SEQ
                          bb := node [ n.startz ] + ( node [ n.dz ] * t )
                          IF
                            bb < plane [ pxz.z ]
                              proceed := FALSE
                            bb > ( plane [ pxz.z ] + plane [ pxz.sizez ] )
                              proceed := FALSE
                            TRUE
                              SKIP
                          IF
                            proceed  -- e.g. value on z axis valid
                              SEQ
                                node [ n.sectx] := aa
                                node [ n.secty] := plane [ pxz.y ]
                                node [ n.sectz] := bb
                                node [ n.normx] := 0.0 (REAL32)
                                IF
                                  node [ n.dy ] > 0.0 (REAL32)
                                    node [ n.normy] := -1.0 (REAL32)
                                  TRUE
                                    node [ n.normy] := 1.0 (REAL32)
                                node [ n.normz] := 0.0 (REAL32)
                            TRUE
                              iNode [n.t] := 0
                      TRUE
                        iNode [n.t] := 0
                TRUE
                  iNode [n.t] := 0
          TRUE
            iNode [n.t] := 0  -- no intersection
    :
    INT nrays :

    PROC sceneSect ( INT nodePtr, VAL BOOL shadowRay )
      iNode IS [ tree FROM nodePtr FOR nodeSize ] :
      [nodeSize] REAL32 fNode RETYPES iNode :
      t IS fNode [n.t] :

      VAL minSect  IS 0.01 (REAL32) :
      VAL INT iminSect RETYPES minSect  :

      INT  ptr, obj.p :
      BOOL proceed :

      [nodeSize] INT     closest :
      [nodeSize] REAL32 fclosest RETYPES closest :
      SEQ
        nrays := nrays + 1
        closest := iNode -- copies ptrs, dx, dy etc.
        proceed := TRUE  -- a quick 'get out' clause for shadow checking
        obj.p   := nil
        ptr     :=   0
        WHILE (worldModel [ptr] <> nil) AND proceed
          size   IS worldModel [ptr] :
          object IS [ worldModel FROM ptr+1 FOR size ] :
          [] REAL32 fobject RETYPES object :
          
          BOOL garbage:
          SEQ
            garbage := TRUE
            IF
              object [o.type] = o.sphere
                SEQ
                  sphereSect ( fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.ellipsoid
                SEQ
                  ellipsoidSect ( fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.cylinder
                SEQ
                  cylinderSect ( fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.cone
                SEQ
                  coneSect ( fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.plane
                SEQ
                  planeSect (fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.xyplane
                SEQ
                  xyPlaneSect (fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.yzplane
                SEQ
                  yzPlaneSect (fNode, fobject )
                  garbage := FALSE
              object [o.type] = o.xzplane
                SEQ
                  xzPlaneSect (fNode, fobject )
                  garbage := FALSE
              TRUE
                SKIP
            IF
              garbage
                SEQ
                  writef ("*N*CGarbage object %I in list at offset %I",
                    object [o.type], ptr, 0, 0 )
                  STOP
              TRUE
                IF
                  iNode [n.t] = 0
                    SKIP
                  shadowRay
                    SEQ
                      proceed := FALSE
                      iNode [n.objptr] := nil
                  obj.p = nil
                    SEQ
                      obj.p := ptr   -- pointer to type slot in world model
                      iNode [ n.objptr] := obj.p
                      closest := iNode
                  t < fclosest [n.t]
                    SEQ
                      obj.p := ptr   -- pointer to size slot in world model
                      iNode [ n.objptr] := obj.p
                      closest := iNode
                  TRUE
                    SKIP
            ptr := ptr + (size + 1)
        IF
          shadowRay
            SKIP
          TRUE
            iNode := closest
    :

    PROC claim ( INT nodePtr, VAL INT type )
      node IS [ tree FROM freeNode FOR nodeSize] :
      SEQ
        nodePtr  := freeNode
        node [n.reflect] := nil
        node [n.refract] := nil
        node [   n.next] := nil
        node [ n.objptr] := nil
        node [   n.type] := type
        freeNode := freeNode + nodeSize
    :

    PROC shadeNode ( VAL INT nodePtr )
      --
      -- Total intensity at node is sum of ambient, diffuse, glossy,
      -- specular and transmitted intensities.
      --
      --                            j=ls
      --                             _  _ _
      -- I = (Ia * kd) + Ig + kd *   > (N.Lj)
      --                             -
      --                            j=1
      --
      -- Here we compute ambient diffuse and glossy terms, specular
      -- and transmitted components are added at mix time.
      --
      -- Ig is given by Phong
      --
      --      j=ls
      --       _  _ _   n
      -- Ig =  > (N.Lj')
      --       -
      --      j=1
      --
      --
      --

      inode   IS [  tree FROM nodePtr FOR nodeSize] :
      node    IS [ ftree FROM nodePtr FOR nodeSize] :
      objPtr  IS inode [ n.objptr] :
      colour  IS [ node FROM n.red FOR 3 ] :
      VAL z     IS 0.0 (REAL32) :
      VAL black IS [ z, z, z ] :
      IF
        objPtr = nil
          colour := ambient
        TRUE
          VAL size    IS worldModel [ objPtr] :
          VAL object  IS [ fworld FROM objPtr + 1 FOR size ] : -- float
          VAL spec    IS object [ o.kg] : -- gloss coefficient
          VAL INT attr RETYPES object [ o.attr] :

          INT shadow, phong :  -- ptr into tree for shadow ray, pseudo light
          INT lightPtr :
          SEQ
            IF
              (attr /\ a.spec) = 0
                SEQ
                  colour [0] := ambient [0] * object [ o.kdR]
                  colour [1] := ambient [1] * object [ o.kdG]
                  colour [2] := ambient [2] * object [ o.kdB]
              TRUE
                colour := black
            claim ( shadow, rt.root )
            claim ( phong,  rt.root )

            shadowNode IS [ ftree FROM shadow FOR nodeSize ] :
            phongNode  IS [ ftree FROM phong  FOR nodeSize ] :

            [nodeSize] INT ishadowNode RETYPES shadowNode :
            SEQ
              lightPtr := 0
              shadowNode [n.startx] := node [ n.sectx] + node [ n.normx]
              shadowNode [n.starty] := node [ n.secty] + node [ n.normy]
              shadowNode [n.startz] := node [ n.sectz] + node [ n.normz]
              WHILE lights [ lightPtr] <> nil
                size  IS lights [ lightPtr] :
                light IS [ flights FROM lightPtr + 1 FOR size ] :  -- float
                SEQ
                  SEQ
                    -- set up shadow ray direction cosines
                    [ shadowNode FROM n.dx FOR 3 ] := [ light FROM l.dx FOR 3 ]
                    sceneSect ( shadow, TRUE )
                  IF
                    ishadowNode [n.t] <> 0
                      SKIP
                    TRUE
                      REAL32 lambert :
                      SEQ
                        dotProduct ( lambert,
                                   [ light FROM l.dx    FOR 3 ],
                                   [ node  FROM n.normx FOR 3 ] )
                        INT iLambert RETYPES lambert :
                        IF
                          (iLambert /\ mint) <> 0  -- -ve !
                            SKIP
                          TRUE
                            SEQ
                              colour [0] := colour [0] +
                                      (lambert * (object [ o.kdR] * light [ l.ir]))
                              colour [1] := colour [1] +
                                      (lambert * (object [ o.kdG] * light [ l.ig]))
                              colour [2] := colour [2] +
                                      (lambert * (object [ o.kdB] * light [ l.ib]))
                        --
                        -- the phong shader is a mite messy at the moment, with lots of
                        -- sign inversions all over the place. I'm not sure they can be avoided
                        --
                        IF
                          (attr /\ a.spec) <> 0
                            REAL32 cosPhong :
                            INT    iCosPhong RETYPES cosPhong :
                            SEQ
                              [ shadowNode  FROM n.normx FOR 3 ] :=
                                     [ node FROM n.normx FOR 3 ]

                              [ shadowNode  FROM n.sectx FOR 3 ] :=
                                     [ node FROM n.sectx FOR 3 ]
                              --
                              --  a nasty sign inversion due to the light direction being optimized
                              --  for shadow spotting
                              --
                              ishadowNode [ n.dx] := ishadowNode [ n.dx] >< mint
                              ishadowNode [ n.dy] := ishadowNode [ n.dy] >< mint
                              ishadowNode [ n.dz] := ishadowNode [ n.dz] >< mint


                              REAL32 Vprime :   -- to keep reflect ray happy
                              [3] REAL32 Vvec :
                              BOOL signFlip :

                              reflectRay ( phong, shadow, Vprime,
                                           Vvec, signFlip )
                              [3] REAL32 flipNode :
                              [3] INT iflip RETYPES flipNode :
                              --
                              --  again, a nasty sign inversion is required here - see diagram
                              -- newmann / sproull, p. 391
                              --
                              SEQ
                                flipNode := [ node FROM n.dx FOR 3 ]
                                iflip [0] := iflip [0] >< mint
                                iflip [1] := iflip [1] >< mint
                                iflip [2] := iflip [2] >< mint
                                dotProduct ( cosPhong,
                                           flipNode,
                                           [ phongNode FROM n.dx FOR 3 ] )
                              IF
                                (iCosPhong /\ mint) <> 0
                                  iCosPhong := iCosPhong >< mint
                                TRUE
                                  SEQ

                                    cosPhong := (cosPhong * cosPhong) -- power := 2
                                    cosPhong := (cosPhong * cosPhong) -- power := 4
                                    cosPhong := (cosPhong * cosPhong) -- power := 8
                                    colour [0] := colour [0] +
                                         (spec * (cosPhong * light [ l.ir]))
                                    colour [1] := colour [1] +
                                         (spec * (cosPhong * light [ l.ig]))
                                    colour [2] := colour [2] +
                                         (spec * (cosPhong * light [ l.ib]))
                          TRUE
                            SKIP
                  lightPtr := lightPtr + (size + 1)

    :


    PROC mixChildren ( VAL INT nodePtr )
      --
      -- Total intensity at node is sum of ambient, diffuse, glossy, specular and
      -- transmitted intensities.
      --
      --
      --                    j=ls _ _
      -- I = Ia + Ig + kd *   { (N.Lj)
      --                    j=1
      --
      -- Here we attenuate specular and transmitted components
      -- from the children, and add into the parent node.
      --


      inode   IS [  tree FROM nodePtr FOR nodeSize] :
      node    IS [ ftree FROM nodePtr FOR nodeSize] :

      objPtr IS inode [ n.objptr] :
      size   IS worldModel [ objPtr] :
      object IS [ fworld FROM objPtr + 1 FOR size ] :  -- float

      VAL z IS 0.0 (REAL32) :
      VAL black IS [ z, z, z ] :

      [3] REAL32 xmit, spec :
      VAL specPtr IS inode [ n.reflect ] :
      VAL fracPtr IS inode [ n.refract ] :
      SEQ
        IF
          specPtr = nil
            SEQ
              spec := black
          TRUE
            SEQ
              -- specular contribution is independent of colour of surface
              -- but here we should attenuate according to 't' ( distance
              -- ray has travelled)
              spec := [ ftree FROM specPtr + n.red FOR 3 ]
              spec [0] := spec [0] * object [ o.ks]
              spec [1] := spec [1] * object [ o.ks]
              spec [2] := spec [2] * object [ o.ks]
        IF
          fracPtr = nil
            SEQ
              xmit := black
          TRUE
            SEQ
              xmit := [ ftree FROM fracPtr + n.red FOR 3 ]
              xmit [0] := xmit [0] * object [ o.xmitR]
              xmit [1] := xmit [1] * object [ o.xmitG]
              xmit [2] := xmit [2] * object [ o.xmitB]
              -- colour the transmitted light
              -- but here we should attenuate according to 't' of ray


        node [   n.red] := node [   n.red] + (spec [0] + xmit [0])
        node [ n.green] := node [ n.green] + (spec [1] + xmit [1])
        node [  n.blue] := node [  n.blue] + (spec [2] + xmit [2])
    :


    PROC shade ( VAL INT rootNode )
      --  Action
      --  ------
      --
      --  We enter proc shade with a pointer into the root node of the tree,
      --  and exit with 3 10-bit integer values in the root node's r g b fields
      --
      --  This proc performs bottom-up shading of the ray intersection tree
      --
      --  Its action is equivalent to
      --
      --  PROC shade ( VAL INT node )
      --    SEQ
      --      IF
      --        tree [ node + n.reflect] <> nil
      --          shade ( tree [ node + n.reflect])
      --        TRUE
      --          SKIP
      --      IF
      --        tree [ node + n.refract] <> nil
      --          shade ( tree [ node + n.refract])
      --        TRUE
      --          SKIP
      --      shadeNode ( node)
      --      mixNode   ( node)
      --  :
      --
      --  where shadeNode () shades this intersection according to lighting
      --        conditions and surface properties
      --
      --  and   mixNode () mixes together the node + its children according to the
      --        surface transmission / reflectance properties
      --
      VAL a.stop    IS 0 :
      VAL a.refract IS 1 :
      VAL a.mix     IS 2 :
      VAL a.reflect IS 3 :

      --
      -- these are designed so that
      --
      --   push2 ( action, node )
      --  and
      --   pop2  ( action, node )  do what you expect
      --
      -- is equivalent to
      --
      -- SEQ
      --   c := a
      --   d := b
      --
      [(maxDepth + 2) * 2] INT stack :
      INT sp :

      PROC push2 ( VAL INT a,b )
        SEQ
          stack [   sp] := a
          stack [ sp+1] := b
          sp := sp + 2
      :

      PROC pop2 ( INT a,b )
        SEQ
          sp := sp - 2
          a  := stack [   sp]
          b  := stack [ sp+1]
      :

      INT nodePtr, action :
      SEQ
        sp      := 0
        push2 ( nil, a.stop )          -- pre load stack with 'terminate' action
        nodePtr := rootNode
        action  := a.reflect
        WHILE action <> a.stop
          node IS [ tree FROM nodePtr FOR nodeSize] :
          spec IS node [ n.reflect] :
          frac IS node [ n.refract] :
          IF
            action = a.reflect
              IF
                spec = nil   -- no reflected ray, shade refracted ray
                  action := a.refract
                frac = nil
                  SEQ
                    push2 ( nodePtr, a.mix )
                    nodePtr := spec
                TRUE
                  SEQ
                    push2 ( nodePtr, a.refract )  -- direction to go on return
                    nodePtr := spec
            frac = nil
              SEQ
                shadeNode   ( nodePtr )      -- shade leaf node
                pop2 ( nodePtr, action )
                WHILE action = a.mix         -- all these nodes have had their
                  SEQ                        -- children shaded, so we can shade
                    shadeNode   ( nodePtr )  -- and mix them
                    mixChildren ( nodePtr )
                    pop2 ( nodePtr, action )
            TRUE
              SEQ
                push2 ( nodePtr, a.mix )
                nodePtr := frac
                action  := a.reflect
        root    IS [ ftree FROM rootNode FOR nodeSize ] :
        [nodeSize] INT iroot   RETYPES root :

        red     IS root [   n.red] :
        green   IS root [ n.green] :
        blue    IS root [  n.blue] :

        ired    IS iroot [   n.red] :
        igreen  IS iroot [ n.green] :
        iblue   IS iroot [  n.blue] :

        VAL maxC IS 1022.99  (REAL32) :  -- just under 10 bits
        REAL32 maxP, fudge :
        BOOL desaturate :
        SEQ
          desaturate := TRUE
          IF
            red > green
              maxP := red
            TRUE
              maxP := green
          IF
            maxP > blue
              IF
                maxP > maxC
                  fudge := maxC / maxP
                TRUE
                  desaturate := FALSE
            blue > maxC
              fudge := maxC / blue
            TRUE
              desaturate := FALSE
          IF
            desaturate
              SEQ
                ired   := INT TRUNC (red   * fudge)
                igreen := INT TRUNC (green * fudge)
                iblue  := INT TRUNC (blue  * fudge)
            TRUE
              SEQ
                ired   := INT TRUNC red
                igreen := INT TRUNC green
                iblue  := INT TRUNC blue
    :

    PROC buildShadeTree ( INT rootNode, VAL REAL32 x, y )
      --
      -- This is a fairly complex piece of code, and isnt obvious.
      --
      -- buildShadeTree is the recursive guts of the ray tracer, performing
      -- reflection / refraction where necessary.
      --
      -- we build the tree breadth first rather than depth first, hence
      -- maintaining a balanced tree. To do this we must maintain a linked
      -- list of active leaf nodes during the build process
      --
      -- We walk down the linked list of leaf nodes at tree level N,
      -- chaining out these leaf nodes whilst constructing a new linked list
      -- of leaf nodes for level N+1.
      --
      -- PROC buildNode ...
      --
      -- intoNode  is passed as a location in the tree, and can thus be assigned
      --
      -- e.g tree [ prev + n.next]
      --
      -- outofNode is a variable POINTER into the tree, and must be indirected
      --
      -- e.g node + n.next
      --
      -- On exiting buildNode outofNode has been updated to point to the location
      -- in the tree which should be passed as 'intoNode' for the next instance
      --
      PROC evolveNode ( INT intoNode, outofNode, nodePtr, spawn )
        SEQ
          sceneSect ( nodePtr, FALSE ) -- NOT casting shadow rays
          node IS [ tree FROM nodePtr FOR nodeSize ] :  -- integer node
          SEQ
            IF
              node [ n.objptr] = nil
                spawn := 0
              TRUE

                VAL  objptr IS node [ n.objptr] :
                VAL  attr   IS worldModel [ objptr + (o.attr  + 1)] : -- skip size

                REAL32 Vprime :
                [3] REAL32 Vvec :

                BOOL flect, signFlip, tIR :
                INT  spec :
                SEQ
                  IF
                    (attr /\ a.spec) <> 0
                      SEQ
                        claim  ( spec, rt.spec )
                        node [ n.reflect ] := spec
                        intoNode := spec         -- chain me into list of leaves
                        reflectRay ( spec, nodePtr, Vprime, Vvec, signFlip )
                        flect := TRUE
                    TRUE
                      flect := FALSE
                  IF
                    flect AND ((attr /\ a.frac) <> 0)
                      INT frac :
                      SEQ
                        claim ( frac, rt.frac )
                        refractRay ( frac, nodePtr, Vprime, Vvec, signFlip, tIR )
                        IF
                          tIR   -- total internal reflection
                            SEQ
                              outofNode := spec + n.next  -- return pointer into tree
                              spawn := 1
                          TRUE
                            SEQ
                              node [ n.refract ] := frac
                              tree [ spec + n.next] := frac
                              spawn := 2
                              outofNode := frac + n.next
                    flect
                      SEQ
                        outofNode := spec + n.next  -- return pointer into tree
                        spawn := 1
                    TRUE
                      spawn := 0
      :

      INT head :
      PROC evolveTree ( INT nodesAdded  )
        INT spawn, node, next, prev :
        SEQ
          node  := head
          next  := node + n.next
          evolveNode ( head, next, node, nodesAdded )
          WHILE tree [ node + n.next] <> nil
            SEQ
              prev := next
              next := node + n.next
              node := tree [ next]
              evolveNode ( tree [ prev], next, node, spawn )
              nodesAdded := nodesAdded + spawn
          tree [ next] := nil
      :

      PROC createRay ( VAL INT rootRay, VAL REAL32 x, y )
        --
        --  takes an (x, y) in screen space, floating point and turns it into
        --  an (x,y,z) (dx,dy,dz) vector
        --
        node IS [ ftree FROM rootRay FOR nodeSize ] :
        REAL32 scrx, scry, hyp :
        SEQ

          scrx := 512.0 (REAL32) - x
          scry := 512.0 (REAL32) - y

          node [ n.startx] := screenOrg [0] +
                            ((scrx * screendX [0]) +
                             (scry * screendY [0]))

          node [ n.starty] := screenOrg [1] +
                            ((scrx * screendX [1]) +
                             (scry * screendY [1]))

          node [ n.startz] := screenOrg [2] +
                            ((scrx * screendX [2]) +
                             (scry * screendY [2]))

          node [ n.dx] := pinhole [0] - node [ n.startx]
          node [ n.dy] := pinhole [1] - node [ n.starty]
          node [ n.dz] := pinhole [2] - node [ n.startz]
          normalize ( [ node FROM n.dx FOR 3 ], hyp )
      :

      INT newNodes, nodes, depth :
      SEQ
        freeNode := 0                     -- initialize tree
        nodes    := 0
        depth    := 1
        claim     ( rootNode, rt.root )    -- get root ray
        createRay ( rootNode, x, y    )    -- build direction cosines etc.
        head := rootNode                   -- init linked list of leaves
        tree [ rootNode + n.next] := nil   -- close linked list
        evolveTree ( newNodes )
        WHILE (depth < maxDepth) AND (newNodes <> 0)
          SEQ
            nodes := nodes + newNodes
            depth := depth + 1
            evolveTree ( newNodes )
    :

    PROC renderPixels ( VAL INT patchx, patchy,
                          x0, y0,
                  [gridSize][gridSize] INT patch,
                  INT colour,
                  VAL INT patchSize, renderingMode )

      PROC findRange ( INT range, VAL INT a, b, c, d )
        INT max, min :
        SEQ
          IF
            a > b
              SEQ
                max := a
                min := b
            TRUE
              SEQ
                max := b
                min := a
          IF
            c > max
              max := c
            c < min
              min := c
            TRUE
              SKIP
          IF
            d > max
              max := d
            d < min
              min := d
            TRUE
              SKIP
          range := max - min
      :

      PROC pointSample ( INT colour, VAL INT x, y )
        patch.p IS patch [y][x] :
        IF
          patch.p = notRendered
            INT tx, ty :
            REAL32 wx, wy :
            INT tree.p :
            SEQ
              tx := (patchx << maxDescend) + x
              ty := (patchy << maxDescend) + y

              wx := (REAL32 TRUNC tx) / (REAL32 TRUNC descendPower)
              wy := (REAL32 TRUNC ty) / (REAL32 TRUNC descendPower)

              buildShadeTree ( tree.p, wx, wy )
              shade ( tree.p )
              node IS [ tree FROM tree.p FOR nodeSize ] :
              colour :=   node [   n.red] \/
                        ((node [ n.green] <<  colourBits) \/
                        ( node [  n.blue] << (colourBits + colourBits)))
              patch.p := colour
          TRUE
            colour := patch.p
      :

      [maxDescend * (4 * 17)] INT    stack : -- 4 * (render, x, y, hop); shade
      [(maxDescend + 1) *  4] INT colstack : --
      INT sp, cp :
      INT    x, y, hop :
      VAL a.render IS 0 :
      VAL a.shade  IS 1 :
      VAL a.stop   IS 2 :

      INT action :
      IF
        renderingMode = m.adaptive
          SEQ
            cp        := 0                 -- empty colour stack
            action    := a.render          -- init action

            stack [0] := a.stop
            stack [1] := descendPower      -- set grid hop value to gross pixel level
            stack [2] := y0 << maxDescend
            stack [3] := x0 << maxDescend  -- locations within this patch
            sp        := 4                 -- pre load stack with render x y hop; stop
            WHILE action <> a.stop
              IF
                action = a.render
                  INT a, b, c, d, rRange, gRange, bRange :
                  VAL sg IS colourBits :
                  VAL sb IS colourBits + colourBits :
                  SEQ
                    VAL record IS [ stack FROM sp - 3 FOR 3 ] :
                    SEQ
                      x   := record [2]
                      y   := record [1]
                      hop := record [0]
                    sp := sp - 3

                    pointSample ( a, x,       y      )
                    pointSample ( b, x + hop, y      )
                    pointSample ( c, x,       y + hop)
                    pointSample ( d, x + hop, y + hop)

                    findRange ( rRange, a /\ rMask, b /\ rMask,
                                        c /\ rMask, d /\ rMask)

                    findRange ( gRange, (a /\ gMask) >> sg, (b /\ gMask) >> sg,
                                        (c /\ gMask) >> sg, (d /\ gMask) >> sg)

                    findRange ( bRange, a >> sb, b >> sb,
                                        c >> sb, d >> sb)

                    IF
                      (hop <> 1) AND
                        ((rRange > threshold) OR
                        ((gRange > threshold) OR (bRange > threshold)))
                        record IS [ stack FROM sp FOR 17 ] :
                        SEQ
                          hop := hop >> 1
                          record [0] := a.shade
                          VAL recordStart IS 1 :
                          SEQ
                            record [recordStart + 0] := hop
                            record [recordStart + 1] := y
                            record [recordStart + 2] := x
                            record [recordStart + 3] := a.render
                          VAL recordStart IS 5 :
                          SEQ
                            record [recordStart + 0] := hop
                            record [recordStart + 1] := y
                            record [recordStart + 2] := x + hop
                            record [recordStart + 3] := a.render
                          VAL recordStart IS 9 :
                          SEQ
                            record [recordStart + 0] := hop
                            record [recordStart + 1] := y + hop
                            record [recordStart + 2] := x
                            record [recordStart + 3] := a.render
                          VAL recordStart IS 13 :
                          SEQ
                            record [recordStart + 0] := hop
                            record [recordStart + 1] := y + hop
                            record [recordStart + 2] := x + hop
                            record [recordStart + 3] := a.render
                          sp := sp + 17
                      TRUE
                        INT R, G, B, m :
                        SEQ
                          m := rMask
                          R := ((((a /\ m) + (b /\ m)) +
                                 ((c /\ m) + (d /\ m))) >> 2) /\ m
                          m := gMask
                          G := ((((a /\ m) + (b /\ m)) +
                                 ((c /\ m) + (d /\ m))) >> 2) /\ m
                          m := bMask
                          B := ((((a /\ m) PLUS (b /\ m)) PLUS
                                 ((c /\ m) PLUS (d /\ m))) >> 2) /\ m
                          colstack [cp] := R \/ (G \/ B)
                          cp := cp + 1
                    sp     := sp - 1
                    action := stack [sp]
                action = a.shade
                  INT a, b, c, d, R, G, B, m :
                  record IS [ colstack FROM cp - 4 FOR 4 ] :
                  SEQ
                    a  := record [3]
                    b  := record [2]
                    c  := record [1]
                    d  := record [0]
                    m := rMask
                    R := ((((a /\ m) + (b /\ m)) +
                           ((c /\ m) + (d /\ m))) >> 2) /\ m
                    m := gMask
                    G := ((((a /\ m) + (b /\ m)) +
                           ((c /\ m) + (d /\ m))) >> 2) /\ m
                    m := bMask
                    B := ((((a /\ m) PLUS (b /\ m)) PLUS
                           ((c /\ m) PLUS (d /\ m))) >> 2) /\ m
                    record [0] := R \/ (G \/ B)
                    cp := cp - 3
                    sp := sp - 1
                    action := stack [ sp]
            colour := colstack [ cp-1]
        renderingMode = m.stochastic
          SEQ
        renderingMode = m.dumb
          INT tree.p :
          INT    tx, ty :
          REAL32 wx, wy :
          SEQ
            tx := ((patchx + x0) << maxDescend)
            ty := ((patchy + y0) << maxDescend)

            wx := (REAL32 TRUNC tx) / (REAL32 TRUNC descendPower)
            wy := (REAL32 TRUNC ty) / (REAL32 TRUNC descendPower)

            buildShadeTree ( tree.p, wx, wy )
            shade ( tree.p )
            node IS [ tree FROM tree.p FOR nodeSize ] :
            colour :=   node [   n.red] \/
                      ((node [ n.green] <<  colourBits) \/
                      ( node [  n.blue] << (colourBits + colourBits)))

        renderingMode = m.test
          colour := (x0 + (y0 * patchSize))
    :

    INT command, nobj, nlight, nrender :

    SEQ
      nrays   := 0
      nobj    := 0
      nlight  := 0
      nrender := 0
      command := 0         -- clear command for when i move to bytes
      world.p := 0         -- empty world model
      light.p := 0         -- and lights list
      mess.p  := 0         -- clear debug message
      workIn ? command     -- (eventually) pull in 1 byte
      WHILE command <> c.stop
        SEQ
          IF
            command = c.render
              INT x0, y0 :
              SEQ
                workIn ? x0; y0
                IF
                  renderingMode = m.adaptive
                    initWORDvec ( rawSamples, notRendered, gridSize * gridSize )
                  TRUE
                    SKIP
                SEQ x = 0 FOR runPatchSize
                  SEQ y = 0 FOR runPatchSize
                    renderPixels ( x0, y0, x, y, samples, colours [y][x],
                                   runPatchSize, renderingMode )
                done ! 42
                pixelsOut ! c.patch; x0; y0; runPatchSize
                SEQ y = 0 FOR runPatchSize
                  pixelsOut ! [ colours [y] FROM 0 FOR runPatchSize ]
                nrender := nrender + 1
            command = c.object
              SEQ
                nobj := nobj + 1
                workIn ? worldModel [ world.p];
                       [ worldModel FROM world.p + 1 FOR worldModel [ world.p]]
                world.p := world.p + (worldModel [ world.p] + 1)
            command = c.light
              REAL32 hyp :
              SEQ
                nlight := nlight + 1
                workIn ? lights [ light.p] ;
                       [ lights FROM light.p + 1 FOR lights [ light.p]]
                normalize ( [ flights FROM light.p + (l.dx + 1) FOR 3 ], hyp )
                light.p := light.p + (lights [ light.p] + 1)
            command = c.runData
              INT size :
              SEQ
                workIn ? size; [ runData FROM 0 FOR size ]
                lights     [ light.p] := nil
                worldModel [ world.p] := nil
            TRUE
              SEQ
                writef ( "*N*C received garbage command %I", command, 0, 0, 0 )
                STOP
          workIn ? command
      writef ( "*N*C Worker %I DONE, %I rays, %I render jobs", me, nrays, nrender, 0 )
      IF
        me = 0
          writef ( "*N*C Scene of %I objects and %I lights", nobj, nlight, 0, 0 )
        TRUE
          SKIP
      pixelsOut ! command
  :

  CHAN OF ANY pixelFeed, pixelTrigger, pixelOut :

  [2][256] INT buffers :

  WHILE TRUE
    PRI PAR
      PAR
        throughPut  ( buffers [0],
                      fromPrev, toNext, pixelFeed, pixelTrigger, propogate )
        pixelBypass ( buffers [1],
                      toPrev, fromNext, pixelOut )
      renderer ( pixelFeed, pixelOut, pixelTrigger )
:
